<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>Types Don't Know #</title>

	<style>
	p {text-align:justify}
	li {text-align:justify}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
	ins {color:#00A000}
	del {color:#A00000}
	</style>
</head>
<body>

<address align=right>
<br/>
<br/>
<a href="mailto:howard.hinnant@gmail.com">Howard E. Hinnant</a><br/>
<a href="mailto:vinnie.falco@gmail.com">Vinnie Falco</a><br/>
2014-04-06
</address>
<hr/>
<h1 align=center>Types Don't Know #</h1>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Example">The Example</a></li>
<li><a href="#Solution1">Solution 1: Specialize <code>std::hash&lt;X&gt;</code></a></li>
<li><a href="#Solution2">Solution 2: Make use of a well-known hashing algorithm</a></li>
<li><a href="#generalpurpose">How to get X to use a general purpose hashing algorithm</a>
    <ul>
    <li><a href="#Universal">Introducing the Universal hash function!</a></li>
    <li><a href="#hash_append">What is <code>hash_append</code>?</a>
        <ul>
        <li><a href="#hash_append_rules">Rules Relating <code>hash_append</code> to <code>operator==</code></a></li>
        </ul>
    </li>
    <li><a href="#hash_append_vector"><code>hash_append</code> for <code>vector&lt;T, A&gt;</code></a></li>
    <li><a href="#hash_append_pair"><code>hash_append</code> for <code>std::pair&lt;T, U&gt;</code></a></li>
    <li><a href="#hash_append_int"><code>hash_append</code> for <code>int</code></a></li>
    <li><a href="#is_contiguously_hashable">An Optimization: <code>is_contiguously_hashable&lt;T&gt;</code>:</a></li>
    <li><a href="#strings">Strings are really important.  What say ye about strings?</a></li>
    <li><a href="#hash_combine">Wait a minute.  Isn't <code>hash_append</code> the same thing as <code>boost::hash_combine</code>?</a></li>
    <li><a href="#serialization">Wait a minute.  Isn't <code>hash_append</code> the same thing as serialization?</a></li>
    <li><a href="#variadic">Is there a variadic version of <code>hash_append</code>?</a></li>
    <li><a href="#adapt_algorithm">How easily can algorithms other than FNV-1a be used?</a></li>
    <li><a href="#switch_algorithm">What is involved in switching hashing algorithms?</a></li>
    <li><a href="#pimpl">How does one <code>hash_append</code> Pimpl designs?</a></li>
    <li><a href="#testing">How does the quality of the resulting hash codes compare to the <code>hash_combine</code> solution?</a></li>
    <li><a href="#seeding">How does one apply random seeding?</a></li>
    </ul>
</li>
<li><a href="#Summary">Summary</a>
    <ul>
    <li><a href="#proposedinfrastructure">Summary of proposed infrastructure</a></li>
    </ul>
</li>
<li><a href="#Acknowledgments">Acknowledgments</a></li>
</ul>

<a name="Introduction"></a><h2>Introduction</h2>

<p>
This paper starts with an assertion:
</p>

<blockquote class=note><p>
Types should not know how to hash themselves.
</p></blockquote>

<p>
The rest of this paper begins with demonstrating the problems created when
software systems assume that types do know how to hash themselves, and what
can be done to solve these problems.
</p>

<a name="Example"></a><h2>The Example</h2>

<p>
Instead of starting with a basic example like <code>std::string</code> or
<code>int</code>, this paper will introduce an example class X
that is meant to be representative of a type that a programmer would write,
and would want to create a hash code for:
</p>

<blockquote><pre>
class X
{
    std::tuple&lt;short, unsigned char, unsigned char&gt; date_;
    std::vector&lt;std::pair&lt;int, int&gt;&gt;                data_;

public:
    X();
    // ...
    friend bool operator==(X const&amp; x, X const&amp; y)
    {
        return std::tie(x.date_, x.data_) == std::tie(y.date_, y.data_);
    }
};
</pre></blockquote>

<blockquote class=note><p>
How do we write the hash function for X?
</p></blockquote>

<a name="Solution1"></a><h2>Solution 1: Specialize <code>std::hash&lt;X&gt;</code></h2>

<p>
If we standardize
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3876.pdf">N3876</a>
which gives us <code>hash_combine</code> and <code>hash_val</code> from
<a href="http://www.boost.org/doc/libs/1_55_0/doc/html/hash/combine.html">boost</a>,
then this is relatively doable:
</p>

<blockquote><pre>
namespace std
{

template &lt;&gt;
struct hash&lt;X&gt;
{
    size_t
    operator()(X const&amp; x) const noexcept
    {
        size_t h = 0;
        std::hash_combine (h, std::hash_val(std::get&lt;0&gt;(x.date_)
                                          , std::get&lt;1&gt;(x.date_)
                                          , std::get&lt;2&gt;(x.date_)));
        for (auto const&amp; p : x.data_)
            std::hash_combine (h, std::hash_val(p.first, p.second));
        return h;
    }
};

}  // std
</pre></blockquote>

<p>
And we also need to add a <code>friend</code> statement to our class X:
</p>

<blockquote><pre>
friend class std::hash&lt;X&gt;;
</pre></blockquote>

<p>
Now we can say <code>std::hash&lt;X&gt;{}(x)</code> and we get back a
hash code.  Is it a <i>good</i> hash code? <i>&lt;shrug&gt;</i>.  The
quality of the hash code is unknown.  What hashing algorithm has been
used? <i>&lt;shrug&gt;</i>.  The hashing algorithm is unspecified.  Later
in this paper we will attempt to at least partially answer these questions.
</p>

<p>
Ok, what if we can't leave things up to chance?  We want to use a
hashing algorithm that is known to have some given verifiable
qualities.  How do we do that?
</p>

<a name="Solution2"><h2>Solution 2: Make use of a well-known hashing algorithm</h2>

<p>
There are many hash algorithms freely available, and several of them explored
in <a href="http://blog.aggregateknowledge.com/2011/12/29/choosing-a-good-hash-function-part-2/">this blog</a>.
Which of these algorithms should we use?  Assuming we pick one, how do we
use that algorithm?  As a simple example, let's assume that we wish to use
<a href="http://www.isthe.com/chongo/tech/comp/fnv/index.html">FNV-1a</a>
which can be coded up like this:
</p>

<blockquote><pre>
std::size_t
fnv1a (void const* key, std::size_t len)
{
    unsigned char const* p = static_cast&lt;unsigned char const*&gt;(key);
    unsigned char const* const e = p + len;
    std::size_t h = 14695981039346656037u;
    for (; p &lt; e; ++p)
        h = (h ^ *p) * 1099511628211u;
    return h;
}
</pre></blockquote>

<p>
We have picked FNV-1a, not because it is a terribly good hash algorithm.  It is
just ok.  There are better ones which we will also explore.  We've picked FNV-1a
because it combines reasonable quality with excellent simplicity, making it
ideal to demonstrate the main concept of this paper.
</p>

<p>
If we are willing to assume that there are no padding bits in
<code>std::pair&lt;int, int&gt;&gt;</code> we could first hash
the entire <code>vector</code> with one call to <code>fnv1a</code>:
</p>

<blockquote><pre>
std::size_t h1 = fnv1a (data_.data(), data_.size() * sizeof(std::pair&lt;int, int&gt;&gt;);
</pre></blockquote>

<p>
It isn't the prettiest code in the world.  But it will work.  And if we dare
to make the same (no padding) assumptions about <code>date_</code> we could
write similar code there:
</p>

<blockquote><pre>
std::size_t h2 = fnv1a (&date_, sizeof(date_));
</pre></blockquote>

<p>
Now we just need to combine these two hash function results into one.  And this
is where things get complicated.  And this is the point on which the assumption
that types know how to hash themselves begins to fall apart.
</p>

<p>
What about using the proposed <code>std::hash_combine</code> you rightly ask?
</p>

<p>
That might look something like this:
</p>

<blockquote><pre>
std::size_t h1 = fnv1a (data_.data(), data_.size() * sizeof(std::pair&lt;int, int&gt;&gt;);
std::hash_combine (h1, date_);
return h1;
</pre></blockquote>

<p>
But this doesn't really work.  Internally <code>std::hash_combine</code>
calls <code>std::hash&lt;std::tuple&lt;short, unsigned char, unsigned char&gt;&gt;{}(date_)</code>,
and we don't want to call <code>std::hash</code>.  We don't know what that
code does.  We want to call <code>fnv1a</code>.  And we can't specialize
<code>std::hash</code> to do what we want because we don't "own" any parts
of the type that we want to specialize on (<code>std::tuple</code> and
<code>char</code>).
</p>

<p>
The very best we can do is crib the algorithm from <code>std::hash_combine</code>
is based on.  We can put the entire thing in a <code>std::hash&lt;X&gt;</code>
specialization as shown before:
</p>

<blockquote><pre>
namespace std
{

template &lt;&gt;
struct hash&lt;X&gt;
{
    size_t
    operator()(X const&amp; x) const noexcept
    {
        std::size_t h = fnv1a (&amp;x.date_, sizeof(x.date_));
        std::size_t h2 = fnv1a (x.data_.data(),
                                    x.data_.size()*sizeof(std::pair&lt;int, int&gt;));
        h ^= h2 + 0x9e3779b9 + (h&lt;&lt;6) + (h&gt;&gt;2);
        return h;
    }
};

}  // std
</pre></blockquote>

<p>
By now there should be several alarms going off in your head:
</p>

<ol>
<li>How sure are we that there are no padding bits in <code>pair</code>
and <code>tuple</code>?</li>

<li>That mixing step looks suspicious.  Does it really work for 64 bit
hash codes?</li>

<li>Because of the combining step, this really is no longer FNV-1a.  The
result will likely no longer have the known properties of FNV-1a.  Thus
the original goal of using FNV-1a has been compromised.</li>

<li>If one can't assume no-padding, and/or if one is using a container
that is not contiguous, then there won't be just one combining step.
There will be tons of them.  The combining step will then dominate the hashing
algorithm.  Then we will clearly not be using FNV-1a.  We will be using whatever
that combining step is doing.</li>
</ol>

<p>
The importance of this last point can not be understated.  Good hash
algorithms are notoriously difficult to write, and poor ones notoriously
easy.  This combining step has been pulled from a
<a href="http://goanna.cs.rmit.edu.au/~jz/fulltext/jasist-tch.pdf">paper whose
focus was not investigating the quality of this algorithm</a>.
</p>

<p>
We should note that
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3333.html">N3333</a>
proposes a superior definition of <code>hash_combine</code> that would call
out to a type's customized overload of <code>hash_value</code> for both types
when combining hash codes.  This at least allows the sub-type author to have
full control over the hashing algorithm used for each sub-type.  However 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3333.html">N3333</a>
would still hard-code into the standard a single
<a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function#Concatenation_of_cryptographic_hash_functions">hash concatenation</a>
algorithm.  And as reported in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3876.pdf">N3876</a>,
the lead author of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3333.html">N3333</a>
notes that neither
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3333.html">N3333</a>
nor 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3876.pdf">N3876</a>
solve the problem of letting the client of X easily decide what hashing
algorithm he wants to use, without having to rewrite custom hashers not only
for X, but for all of X's sub-types.
</p>

<p>
Backing up...
</p>

<p>
We do not want to use:
</p>

<blockquote><pre>
seed ^= hash(v) + 0x9e3779b9 + (seed&lt;&lt;6) + (seed&gt;&gt;2);
</pre>
<p>
(or some other
<a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function#Concatenation_of_cryptographic_hash_functions">hash concatenation</a>
function)
</p>
</blockquote>

<p>
We want to use
<a href="http://www.isthe.com/chongo/tech/comp/fnv/index.html">FNV-1a</a>,
or
<a href="https://code.google.com/p/smhasher/wiki/MurmurHash3">MurmurHash3</a>,
or
<a href="https://code.google.com/p/cityhash/">CityHash</a>,
or
<a href="http://burtleburtle.net/bob/hash/spooky.html">SpookyHash</a>,
or whatever on the <i>full</i> state of type X.  Every time we "dilute" one of
these hash algorithms by using a combining step, we dilute the confidence in the
final hash code being produced, as we are no longer using the hashing algorithm
of our choice.
</p>

<p>
In other words, the state of our example X class is like one long message we
wish to hash.  At the top level, the message is the "value" of X.  But that
top level view of the message can be broken down into a series of integral
types (in this case X is composed only of integral types), for example:
</p>

<blockquote><pre>
2014, 4, 5, 2, 3, 7, 3, 16, -9
</pre></blockquote>

<p>
I.e. a date followed by zero or more pairs of ints.  The client of X needs to be
able to choose some hashing algorithm to hash this message, whether it be a
<a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function">cryptographic hash function</a>
from the
<a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2 family</a>,
<a href="http://www.isthe.com/chongo/tech/comp/fnv/index.html">FNV-1a</a>, or
<a href="https://131002.net/siphash/">SipHash</a>.
</p>

<p>
In essence, the type is the wrong place to put knowledge about any given
hash algorithm.  That knowledge belongs in a specialized hashing library.
</p>

<blockquote class=note><p>
Types should not know how to hash themselves.
</p></blockquote>

<p>
The question now becomes:  How do you present X as one long message to an
arbitrary hashing library?  And how do you do so such that one does not need to
revisit X, nor any of X's sub-types when you want to change from one hashing
algorithm to another?
</p>

<a name="generalpurpose"></a><h2>How to get X to use a general purpose hashing algorithm</h2>

<p>
Although most modern hashing algorithms are much more complicated than
<code>fnv1a</code> shown above, there are similarities among them.
</p>

<ul>
<li>They generally take a stream of bytes as their input.  This is often
specified as a  <code>void const*</code> and a <code>size_t</code> length.</li>

<li>
This interface implies that they work on a contiguous array of bytes.
</li>

<li>
The algorithms generally have an initialization stage, often taking an
optional seed, followed by an accumulation stage which depends on the
supplied bytes, followed by a finalization stage after all of the bytes
are consumed.
</li>
</ul>

<p>
Not all, but many of the algorithms also have the property that they consume
bytes in the order that they are received, possibly with a fixed sized internal
buffer.  In the FNV-1a example, that internal buffer is reduced down to a
single byte.  This characteristic can be taken advantage of in order to hash
<i>discontiguous</i> memory.
</p>

<p>
For example consider this minor repackaging of the FNV-1a algorithm:
</p>

<blockquote><pre>
class fnv1a
{
    std::size_t state_ = 14695981039346656037u;
public:
    using result_type = std::size_t;

    void
    operator()(void const* key, std::size_t len) noexcept
    {
        unsigned char const* p = static_cast&lt;unsigned char const*&gt;(key);
        unsigned char const* const e = p + len;
        for (; p &lt; e; ++p)
            state_ = (state_ ^ *p) * 1099511628211u;
    }

    explicit
    operator result_type() noexcept
    {
        return state_;
    }
};
</pre></blockquote>

<p>
Now the algorithm can be accessed in 3 stages:
</p>

<ol>
<li>The algorithm is initialized in a constructor, in this case the
implicit default constructor.  Other constructors / initializations
should be possible.  But we start out with this simplest of algorithms.</li>
<li>The algorithm consumes bytes in the <code>operator()(void const* key,
std::size_t len)</code> function. Note that this function can be called any
number of times.  In each call the memory is contiguous.  But there is no
requirement at all that separate calls refer to a single block of memory.</li>
<li>The algorithm is finalized when the object is converted to a
<code>result_type</code> (in this case a <code>size_t</code>).
This is the finalization stage, which in this
case is trivial, but could be arbitrarily complex.</li>
</ol>

<p>
We can say that <code>fnv1a</code> meets the requirements of a
<code>Hasher</code>.  A <code>Hasher</code> is a class type that can be
constructed (default, or possibly with seeding), has an <code>operator()</code>
member function with the signature represented above.  The
<code>operator()</code> member function processes bytes, updating the internal
state of the <code>Hasher</code>.  This internal state can be arbitrarily
complex.  Indeed an extreme example of internal state could be a copy of every
chunk of memory supplied to the <code>Hasher</code>.  And finally a
<code>Hasher</code> can be explicitly converted to the nested type
<code>result_type</code>, which when used with the unordered containers should
be an alias for <code>size_t</code>.
</p>

<a name="Universal"></a><h3>Introducing the Universal hash function!</h3>

<p>
Given the concept of <code>Hasher</code>, a universal hash functor, which
takes <b>any</b> type <code>T</code> can now be written (almost):
</p>

<blockquote><pre>
template &lt;class Hasher&gt;
struct uhash
{
    using result_type = typename Hasher::result_type;

    template &lt;class T&gt;
    result_type
    operator()(T const&amp; t) const noexcept
    {
        Hasher h;
        using std::hash_append;
        hash_append(h, t);
        return static_cast&lt;result_type&gt;(h);
    }
};
</pre></blockquote>

<p>
Now one can use <code>uhash&lt;fnv1a&gt;</code> as the hash function for
<code>std::unordered_map</code>, for example:
</p>

<blockquote><pre>
std::unordered_map&lt;MyKey, std::string, uhash&lt;fnv1a&gt;&gt; the_map;
</pre></blockquote>

<p>
First note several important attributes of <code>uhash</code>:
</p>

<ol>
<li>
<code>uhash</code> depends only on the hashing algorithm, which is encapsulated
in the <code>Hasher</code>.  <code>uhash</code> does not depend upon the
type <code>T</code> being hashed.
</li>
<li>
<code>uhash</code> is simple.  Though such a utility should certainly be 
supplied by the std::lib, any programmer can very easily implement their own
variant of <code>uhash</code> for desired customizations (e.g. 
<a href="http://en.wikipedia.org/wiki/Random_seed">random seeding</a>,
<a href="http://en.wikipedia.org/wiki/Salt_(cryptography)">salting</a>,
or <a href="http://en.wikipedia.org/wiki/Padding_(cryptography)">padding</a>),
<b>without</b> having to revisit the hashing code for distinct types.
</li>
<li>
For applications other than unordered containers, and for hashing algorithms
that support it, the programmer can easily create a hash functor that returns
something besides a <code>size_t</code>.  For example, this could come in handy
in computing a <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-256</a>
result.  And all without having to revisit each individual type!
</li>
</ol>

<p>
Let's walk through <code>uhash</code> one step at a time.
</p>

<ol>
<li><p>
The <code>Hasher</code> is constructed (default constructed in this example, but
that is not the only possibility).  This step initializes the hashing algorithm
encapsulated in the <code>Hasher</code>.
</p></li>
<li><p>
It is appended to using <code>t</code> as a key.  The function
<code>hash_append</code> is implemented for each type that supports hashing.
We will see below that such support code need be written only once per type in
order to support many hashing algorithms.  It is implemented in the type's own
namespace, but there are implementations in namespace std for most scalars
(just like <code>swap</code>).
</p></li>
<li><p>
And then the <code>Hasher</code> is explicitly converted to the desired result.
This is where the algorithm is "finalized."
</p></li>
</ol>

<p>
The above <code>hash</code> functor is accessing the generic hashing algorithm
by its 3 distinct phases. Additionally, this <code>hash</code> functor could
even be defaulted to use your favorite hash algorithm:
</p>

<blockquote><pre>
template &lt;class Hasher = fnv1a&gt; struct uhash;
</pre></blockquote>

<p>
The question usually arises now:  Are you proposing that <code>uhash&lt;&gt;</code>
replace <code>hash&lt;T&gt;</code> as the default hash functor in the
unordered containers?  The answer is it really almost doesn't matter.  With
templated using declarations, it is just so easy for programmers to specify
their own defaults:
</p>

<blockquote><pre>
namespace my
{
template &lt;class Key, class T, class Hash = std::uhash&lt;&gt;, class Pred = std::equal_to&lt;Key&gt;,
          class Alloc = std::allocator&lt;std::pair&lt;Key const, T&gt;&gt;&gt;
    using unordered_map = std::unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;;
}  // my

// ...

my::unordered_map&lt;MyKey, std::string&gt; the_map;  // uses std::uhash&lt;&gt; instead of std::hash&lt;MyKey&gt;
</pre></blockquote>


<a name="hash_append"></a><h3>What is <code>hash_append</code>?</h3>

<p>
The <code>hash_append</code> function is the glue that binds the individual
types to the general <code>Hasher</code>.
</p>

<ul>
<li>The <code>Hasher</code> knows nothing about the type <code>T</code>
being hashed.</li>
<li>The hash functor <code>uhash</code> knows nothing about the <code>Hasher</code>,
nor the type <code>T</code> being hashed.</li>
<li>Below we will show how each type <code>T</code> can implement
<code>hash_append</code> (much like a type implements <code>swap</code>), and
yet knows nothing about the <code>hash</code> functor, nor the algorithm
encapsulated in the <code>Hasher</code>.</li>
</ul>

<p>
Each type <code>T</code> is responsible only for exposing its hash-worthy state
to the <code>Hasher</code> in the function  <code>hash_append</code>.
<code>T</code> is <i>not</i> responsible for combining hash codes.  Nor is it
responsible for any hashing arithmetic whatsoever.  It is only responsible for
pointing out where its data is, how many different chunks of data there are,
and what order they should be presented to the <code>Hasher</code>.
</p>

<p>
For example, here is how X might implement <code>hash_append</code>:
</p>

<blockquote><pre>
class X
{
    std::tuple&lt;short, unsigned char, unsigned char&gt; date_;
    std::vector&lt;std::pair&lt;int, int&gt;&gt;                data_;

public:
    // ...
    friend bool operator==(X const&amp; x, X const&amp; y)
    {
        return std::tie(x.date_, x.data_) == std::tie(y.date_, y.data_);
    }

    // Hook into the system like this
    template &lt;class Hasher&gt;
    friend void hash_append(Hasher&amp; h, X const&amp; x) noexcept
    {
        using std::hash_append;
        hash_append(h, x.date_);
        hash_append(h, x.data_);
    }
}
</pre></blockquote>

<p>
Like <code>swap</code>, <code>hash_append</code> is a customization point for
each type.  Only a type knows what parts of itself it should expose to a
<code>Hasher</code>, even though the type has no idea what algorithm is being
used to do the hashing.  Furthermore the <code>hash_append</code> function is
intimately tied to the <code>operator==</code> for the same type.  For example
if for some reason <code>x.data_</code> did not participate in the equality
computation, then it should also not participate in the <code>hash_append</code>
computation.
</p>

<a name="hash_append_rules"></a><h4>Rules Relating <code>hash_append</code> to <code>operator==</code></h4>

<p>
For all combination of two values of X, <code>x</code> and <code>y</code>, there
are two rules to follow in designing <code>hash_append</code> for type X. 
Actually the second rule is more of a guideline.  But it should be followed as
closely as possible:
</p>

<ol>
<li><p>
If <code>x == y</code>, then both <code>x</code> and <code>y</code> <i>shall</i>
send the same message to the <code>Hasher</code> in <code>hash_append</code>.
</p></li>
<li><p>
If <code>x != y</code>, then <code>x</code> and <code>y</code> <i>should</i>
send different messages to the <code>Hasher</code> in <code>hash_append</code>.
</p></li>
</ol>

<p>
It is very important to keep these two rules in mind when designing the
<code>hash_append</code> function for any type, or for any instantiation of a
class template.  Failure to follow the first rule will mean that equal values
hash to different codes.  Clients such as unordered containers will simply
fail to work, resulting in run time errors if this rule is violated.  Failure
to follow the second guideline will result in hash collisions for the two
different values that send identical messages to the <code>Hasher</code>, and
will thus degrade the performance of clients such as unordered containers.
</p>

<a name="hash_append_vector"></a><h3><code>hash_append</code> for <code>vector&lt;T, A&gt;</code></h3>

<p>
For example <code>std::vector&lt;T, A&gt;</code> would
never expose its <code>capacity()</code>, since <code>capacity()</code> can be
different for <code>vector</code>'s that otherwise compare equal.  Likewise
it should not expose its <code>allocator_type</code> to <code>hash_append</code>,
since this value also does not participate in the equality computation.
</p>

<p>
Should <code>vector</code> expose its <code>size()</code> to the
<code>Hasher</code>? To find out, lets look closer at the
<code>operator==</code> for <code>vector</code>:
</p>

<blockquote><p>
Two <code>vector</code>'s <code>x</code> and <code>y</code> compare equal if
<code>x.size() == y.size()</code> and if <code>x[i] == y[i]</code> for
<code>i</code> in the range of 0 to <code>x.size()</code>.
</p></blockquote>

<p>
To meet <a href="#hash_append_rules">rule 1</a>, it is sufficient that every element in the <code>vector</code>
be sent to the <code>Hasher</code> as part of the <code>vector</code>'s message.
A logical convention is that the elements will be sent in order from
<code>begin()</code> to <code>end()</code>.  But this alone will not satisfy
<a href="#hash_append_rules">rule 2</a>.  Consider:
</p>

<blockquote><pre>
std::vector&lt;std::vector&lt;int&gt;&gt; v1{};
std::vector&lt;std::vector&lt;int&gt;&gt; v2{1};
assert(v1 != v2);
</pre></blockquote>

<p>
<code>v1</code> and <code>v2</code> are not equal.  <code>v1.size() == 0</code>
and  <code>v2.size() == 1</code>.  However <code>v2.front().size() == 0</code>.
If an empty <code>vector&lt;int&gt;</code> sends no message at all to the
<code>Hasher</code>, then <code>v2</code>, even though it is not empty, also
sends no message to the <code>Hasher</code>.  And therefore <code>v1</code> and
<code>v2</code> send the same (0 length) message to the <code>Hasher</code>,
violating <a href="#hash_append_rules">rule 2</a>.
</p>

<p>
One idea for fixing this is to special case 0-length <code>vector</code>s to 
output a special value such as "empty" or 0.  However in the first case the
result would be ambiguous with a <code>vector&lt;string&gt;</code> of length
1 containing the string "empty".  The second case has the exact same problem
but for <code>vector&lt;int&gt;</code>.
</p>

<p>
The right way to fix this problem is to have  <code>vector&lt;T&gt;</code> send
its <code>size()</code> in addition to sending all of its members to the
<code>Hasher</code>.  Now the only question is:  Should it send its
<code>size</code> before or after sending its members to the <code>Hasher</code>?
</p>

<p>
To answer this last question, consider another sequence container:
<code>forward_list&lt;T&gt;</code>.  It has the exact same issues as we have
been discussing for <code>vector&lt;T&gt;</code>, but <code>forward_list&lt;T&gt;</code>
has no <code>size()</code> member.  In order to send its <code>size()</code>,
<code>forward_list&lt;T&gt;</code> has to loop through all of its members to
first compute <code>size()</code>.  In order to avoid the requirement that
<code>hash_append</code> for <code>forward_list&lt;T&gt;</code> make two
passes through the list, we should specify that the <code>size()</code> of the
container is sent to the <code>Hasher</code> <i>after</i> all of the elements
are sent.  And for consistency, we should do this for all std-containers for
which <code>hash_append</code> is defined.
</p>

<blockquote><pre>
template &lt;class Hasher, class T, class Alloc&gt;
void
hash_append(Hasher&amp; h, std::vector&lt;T, Alloc&gt; const&amp; v) noexcept
{
    for (auto const&amp; t : v)
        hash_append(h, t);
    hash_append(h, v.size());
}
</pre></blockquote>

<p>
I.e. <code>vector</code> considers itself a message composed of 0 or more
sub-messages, and appends each sub-message (in order) to the state of the
generic <code>Hasher</code>.  And this is followed with a final message
consisting of the <code>size()</code> of the <code>vector</code>.
</p>

<p><b>Emphasis</b></p>
<blockquote><p>
The message a type sends to a <code>Hasher</code> is part of its public API.
E.g. whether or not a container includes its <code>size()</code> in its
<code>hash_append</code> message, and if so, whether the  <code>size()</code> is
prepended or appended to the message, is critical information a type's client
needs to know, in order to ensure that their composition of some type's message
with another type's message doesn't produce an ambiguous message (doesn't create
collisions).
</p><p>
The standard should clearly document the message emanating from every
<code>hash_append</code> it defines, to the extent possible (might not be
possible to nail down that an implementation is using IEEE floating point or
two's complement signed integers).  But the standard can certainly document
the message produced by a <code>vector</code> or any other std-defined class
type.
</p></blockquote>

<a name="hash_append_pair"></a><h3><code>hash_append</code> for <code>std::pair&lt;T, U&gt;</code></h3>

<p>
The situation is simpler for <code>std::pair&lt;T, U&gt;</code>:
</p>

<blockquote><pre>
template &lt;class Hasher, class T, class U&gt;
void
hash_append (Hasher&amp; h, std::pair&lt;T, U&gt; const&amp; p) noexcept
{
    hash_append (h, p.first);
    hash_append (h, p.second);
}
</pre></blockquote>

<p>
All there is to do is to just <code>hash_append</code> the first and second
members of the pair.
</p>

<a name="hash_append_int"></a><h3><code>hash_append</code> for <code>int</code></h3>

<p>
Eventually <code>hash_append</code> will drill down to a scalar type such as
<code>int</code>:
</p>

<blockquote><pre>
template &lt;class Hasher&gt;
void
hash_append(Hasher&amp; h, int const&amp; i) noexcept
{
    h(&amp;i, sizeof(i));
}
</pre></blockquote>

<p>
Whereupon a contiguous chunk of memory is actually accumulated by the
<code>Hasher</code>, using the <code>Hasher</code>'s <code>operator()</code>.
 Recall that the <code>Hasher</code> has a member function
<code>operator()(const void* key, std::size_t len) noexcept</code>.  And the
<code>int</code> is just a chunk of <i>contiguous</i> memory that is
<i>hashable</i>.  It is now prudent to deeply consider what it means to say
that a type (such as <code>int</code>) is <i>contiguously hashable</i>.
</p>

<p>
A type <code>T</code> is <i>contiguously hashable</i> if for all combinations of
two values of a type, say <code>x</code> and <code>y</code>, if <code>x ==
y</code>, then it must also be true that <code>memcmp(addressof(x),
addressof(y), sizeof(T)) == 0</code>.  I.e. if <code>x == y</code>, then
<code>x</code> and <code>y</code> have the same bit pattern representation. A
2's complement <code>int</code> satisfies this property because every bit
pattern an <code>int</code> can have results in a distinct value (<a
href="#hash_append_rules">rule 2</a>).  And there are no "padding bits" which might take on
random values.  This property is necessary because if two values are equal, then
they must hash to the same hash code (<a href="#hash_append_rules">rule 1</a>).
</p>

<a name="is_contiguously_hashable"></a><h3>An Optimization: <code>is_contiguously_hashable&lt;T&gt;</code>:</h3>

<p>
With that in mind we can easily imagine a type trait:
</p>

<blockquote><pre>
template &lt;class T&gt; struct is_contiguously_hashable;
</pre></blockquote>

<p>
which derives from either <code>true_type</code> or <code>false_type</code>. And
on 2's complement systems,
<code>is_contiguously_hashable&lt;int&gt;::value</code> is <code>true</code>.
And we might anticipate that some other types, such as <code>char</code> and
<code>long long</code> are also <i>contiguously hashable</i>.  With this
tool we can now easily write <code>hash_append</code> for all contiguously
hashable types:
</p>

<blockquote><pre>
template &lt;class Hasher, class T&gt;
inline
std::enable_if_t
&lt;
    is_contiguously_hashable&lt;T&gt;::value
&gt;
hash_append(Hasher&amp; h, T const&amp; t) noexcept
{
    h(addressof(t), sizeof(t));
}
</pre></blockquote>

<p>
Now the task remains to specialize <code>is_contiguously_hashable</code>
properly for those scalars we want to use this implementation of
<code>hash_append</code> for, and for any other scalars, implement
<code>hash_append</code> appropriately.  As an example of the latter, consider
IEEE floating point types.
</p>

<p>
An IEEE floating point type is <i>not contiguously hashable</i> because <code>0.
== -0.</code> but these two values are represented with different bit patterns. 
<a href="#hash_append_rules">Rule 1</a> would be violated if hashed contiguously. Therefore the
<code>hash_append</code> for IEEE floating point types must go to extra effort
to ensure that <code>0.</code> and <code>-0.</code> hash to identical hash
codes, but <b>without</b> dictating a specific hash algorithm.  This could be
done like so:
</p>

<blockquote><pre>
template &lt;class Hasher, class T&gt;
inline
std::enable_if_t
&lt;
    std::is_floating_point&lt;T&gt;::value
&gt;
hash_append(Hasher&amp; h, T t) noexcept
{
    if (t == 0)
        t = 0;
    h(&amp;t, sizeof(t));
}
</pre></blockquote>

<p>
I.e. if the value is -0., reset the value to 0., and <i>then</i> contiguously
hash the resulting bits.
</p>

<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3333.html">N3333</a>
also introduced a very similar <code>is_contiguous_layout</code> trait.  We
build upon but modify their idea here.  But just because a type has a
<i>contiguous layout</i> does not necessarily imply that a type is
<i>contiguously hashable</i>.  IEEE floating point is a case in point.  IEEE
floating point does have a contiguous layout (and is trivially copyable, and
has a standard layout).  And yet still it is not <i>contiguously hashable</i>
because of how its <code>operator=</code> works with signed zeros (violating
<a href="#hash_append_rules">rule 1</a>).
</p>

<p>
Class types that are composed of only  <i>contiguously hashable</i> types
and that have no padding bytes, may also be considered to be
<i>contiguously hashable</i>.  For example consider this specialization of
<code>is_contiguously_hashable&lt;std::pair&lt;T, U&gt;&gt;</code>:
</p>

<blockquote><pre>
template &lt;class T, class U&gt;
struct is_contiguously_hashable&lt;std::pair&lt;T, U&gt;&gt;
    : public std::integral_constant&lt;bool, is_contiguously_hashable&lt;T&gt;::value &amp;&amp;
                                          is_contiguously_hashable&lt;U&gt;::value &amp;&amp;
                                          sizeof(T) + sizeof(U) == sizeof(std::pair&lt;T, U&gt;)&gt;
{
};
</pre></blockquote>

<p>
In English:  If the <code>pair</code>'s two types are both contiguously
hashable, and if the size of the two members is the same size as the
<code>pair</code> (so there are no padding bytes), then the entire
<code>pair</code> itself is contiguously hashable!
</p>

<p>
This same logic can be applied to <code>array</code>, <code>tuple</code>, and
possibly user-defined types as well (but only with the user-defined type's
author's permission).  Consequently, a great many types can be easily and safely
classified as contiguously hashable.  This is important because with modern hash
algorithm implementations, the bigger the chunk of contiguous memory you can
send to the <code>Hasher</code> at one time, the higher the performance (in
terms of bytes-hashed/second) the <code>Hasher</code> is likely to perform.
</p>

<p>
With that in mind (the bigger the memory chunk the better), consider again
<code>hash_append</code> for <code>vector</code>:
</p>

<blockquote><pre>
template &lt;class Hasher, class T, class Alloc&gt;
inline
std::enable_if_t
&lt;
    !is_contiguously_hashable&lt;T&gt;::value
&gt;
hash_append(Hasher&amp; h, std::vector&lt;T, Alloc&gt; const&amp; v) noexcept
{
    for (auto const&amp; t : v)
        hash_append(h, t);
    hash_append(h, v.size());
}

template &lt;class Hasher, class T, class Alloc&gt;
inline
std::enable_if_t
&lt;
    is_contiguously_hashable&lt;T&gt;::value
&gt;
hash_append(Hasher&amp; h, std::vector&lt;T, Alloc&gt; const&amp; v) noexcept
{
    h(v.data(), v.size()*sizeof(T));
    hash_append(h, v.size());
}
</pre></blockquote>

<p>
I.e. if the <code>T</code> <b>is</b> contiguously hashable, then even though
<code>vector</code> itself is not, there can still be a <i>huge</i> optimization
made by having <code>vector</code> send its <i>contiguous</i> <code>data</code>
buffer to <code>hash_append</code>.
</p>

<p>
This optimization can be made without any help from the <code>std::lib</code>.
Other optimizations are possible, but could only be made from within the
<code>std::lib</code>.  For example, what if <code>T</code> is <code>bool</code>
in the above example?  <code>vector&lt;bool&gt;</code> doesn't follow the usual
<code>vector</code> rules.  What about <code>deque&lt;T&gt;</code>?  It could
hash its internal contiguous buffers all at once, but there is no way to
implement that without intimate knowledge of the internals of the
<code>deque</code> implementation.  Externally, the best one can do for
<code>deque&lt;T&gt;</code> is to send each individual <code>T</code> to
<code>hash_append</code> one at a time.  This still gives the very same correct
message, but is just much slower.
</p>

<p>
If you believe <b>your type</b> to be contiguously hashable, you should
specialize <code>is_contiguously_hashable&lt;YourType&gt;</code> appropriately,
as has been shown for <code>pair</code>.  This would mean that not only is
hashing <code>YourType</code> optimized, but hashing
<code>vector&lt;YourType&gt;</code>, et. al. is also optimized!  But note that
there is no bullet proof way to automate the registration of
<code>YourType</code> with <code>is_contiguously_hashable</code> as IEEE
floating point so ably demonstrates.  To do so requires an in depth analysis
of <code>operator==</code> for <code>YourType</code>, which only the author
of <code>YourType</code> is qualified to do.
</p>

<a name="strings"></a><h3>Strings are really important.  What say ye about strings?</h3>

<p>
Like <code>vector</code>, <code>basic_string</code> can be optimized if the
<code>CharT</code> is contiguously hashable, as it will be for any reasonable
<code>CharT</code>.  But there is an interesting and useful wrinkle...
</p>

<p>
C-style arrays are also hashable:
</p>

<blockquote><pre>
template &lt;class Hasher, class T, std::size_t N&gt;
inline
std::enable_if_t
&lt;
    !is_contiguously_hashable&lt;T&gt;::value
&gt;
hash_append(Hasher&amp; h, T (&amp;a)[N]) noexcept
{
    for (auto const&amp; t : a)
        hash_append(h, t);
}
</pre></blockquote>

<p>
And if <code>T</code> <i>is</i> contiguously hashable, then the generic
<code>hash_append</code> works for C-style arrays (as long as we specialize
<code>is_contiguously_hashable&lt;T[N]&gt;</code>) appropriately.  And, well
this is the good part, the decltype(a-string-literal) is a C-style array type.
For string literals, the array type is always one larger than the
<code>strlen</code> of the literal because the array contains the trailing null
character.  And, by happy coincidence, <code>basic_string</code> now always
embeds a trailing null character as well.  So optimized or not, the
<code>hash_append</code> for <code>basic_string</code> should be specified
to include hashing the trailing null character:
</p>

<blockquote><pre>
template &lt;class Hasher, class CharT, class Traits, class Alloc&gt;
inline
std::enable_if_t
&lt;
    is_contiguously_hashable&lt;CharT&gt;::value
&gt;
hash_append(Hasher&amp; h, std::basic_string&lt;CharT, Traits, Alloc&gt; const&amp; s) noexcept
{
    h(s.data(), (s.size()+1)*sizeof(CharT));
}
</pre></blockquote>

<p>
With this definition, then there is an invariant relationship between
<code>std::string</code> and string literals, no matter what hashing algorithm
is specified by the client:
</p>

<blockquote><pre>
assert(uhash&lt;&gt;{}(std::string("Hi!")) == uhash&lt;&gt;{}("Hi!"));
assert(uhash&lt;MySpecialHasher&gt;{}(std::string("Hi!")) == uhash&lt;MySpecialHasher&gt;{}("Hi!"));
</pre></blockquote>

<p>
String literals and their <code>std::basic_string</code> counterparts hash
identically!  When you think about it in terms of messages, this makes perfect
sense.  Is <code>std::string{"some text"}</code> a different message than
<code>"some text"</code>?  Of course not.  The two identical messages simply
have different storage mechanisms.  They actually compare equal, and thus should
have identical hash codes as well (no matter the hashing algorithm).
This opens the door for the unordered container analogue of:
</p>

<blockquote><pre>
template &lt;class K&gt; iterator find(const K&amp; x);
</pre></blockquote>

<p>
to actually work for the very most important use case!
</p>

<blockquote><pre>
auto i = unordered_set_of_string.find("a string literal used to look up a std::string");
</pre></blockquote>

<p>
And without having to actually construct a <code>std::string</code>!
</p>

<p>
Note that <a href="#hash_append_rules">rules 1 and 2</a> have effectively been expanded to
heterogeneous <code>operator==</code> here.  Since we can compare
<code>string</code>s and <code>char[N]</code>, and it has the obvious meaning,
it also makes sense to message them to a <code>Hasher</code> in such a way that
follows these two rules.
</p>

<a name="hash_combine"></a><h3>Wait a minute.  Isn't <code>hash_append</code> the same thing as
<code>boost::hash_combine</code>?</h3>

<p>No!</p>

<p>
<code>boost::hash_combine</code> is used to combine two separately computed
hash codes into one hash code.  And furthermore it hard-codes the functor to
be used for the second type.
</p>

<p>
The
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3333.html">N3333</a>
<code>hash_combine</code> does not have the fault of hard-coding
the hash algorithm for the second type.  However it does mandate a
<a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function#Concatenation_of_cryptographic_hash_functions">hash concatenation</a>
algorithm.
</p>

<p>
  <code>hash_append</code> accumulates state into
a <i>generic</i> hash algorithm, returning the exact same result as if the
hash algorithm had processed the entire discontiguous memory buffer as one
contiguous memory buffer.  <b>There is no hash concatenation step!</b>
With <code>hash_append</code>, there is only <i>message concatenation</i>, and
not
<a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function#Concatenation_of_cryptographic_hash_functions">hash concatenation</a>.
</p>

<a name="serialization"></a><h3>Wait a minute.  Isn't <code>hash_append</code> the same thing as
serialization?</h3>

<p>
It is very closely related.  Close enough that there may be a way to elegantly
combine the two.  Each type can expose its state to a <code>Hasher</code> or
<code>Serializer</code>.  However there <i>are</i> differences.  IEEE floating
point is our poster-child for the difference.  For hashing, IEEE floating point
needs to hide the difference between -0. and 0.  For serialization one needs to
keep these two values distinct.  Combining these two functions, for now, remains
beyond the scope of this paper.
</p>

<a name="variadic"></a><h3>Is there a variadic version of <code>hash_append</code>?</h3>

<p>
Yes, this is easily written as:
</p>

<blockquote><pre>
template &lt;class Hasher, class T0, class T1, class ...T&gt;
inline
void
hash_append (Hasher&amp; h, T0 const&amp; t0, T1 const&amp; t1, T const&amp; ...t) noexcept
{
    hash_append (h, t0);
    hash_append (h, t1, t...);
}
</pre></blockquote>

<p>
This allows <code>hash_append</code> for X (for example) to be rewritten as:
</p>

<blockquote><pre>
template &lt;class Hasher&gt;
friend void hash_append(Hasher&amp; h, X const&amp; x) noexcept
{
    using std::hash_append;
    hash_append(h, x.date_, x.data_);
}
</pre></blockquote>

<a name="adapt_algorithm"></a><h3>How easily can algorithms other than FNV-1a be used?</h3>

<p>
Algorithms such as
<a href="https://code.google.com/p/cityhash/">CityHash</a> are not easily
adapted to this infrastructure, because as currently coded, CityHash actually
hashes the end of the buffer first.  However
<a href="http://burtleburtle.net/bob/hash/spooky.html">SpookyHash</a>, which
is reported to have quality comparable to CityHash is trivial to incorporate:
</p>

<blockquote><pre>
#include "SpookyV2.h"

class spooky
{
    SpookyHash state_;
public:
    using result_type = std::size_t;

    spooky(std::size_t seed1 = 1, std::size_t seed2 = 2) noexcept
    {
        state_.Init(seed1, seed2);
    }

    void
    operator()(void const* key, std::size_t len) noexcept
    {
        state_.Update(key, len);
    }

    explicit
    operator result_type() noexcept
    {
        std::uint64_t h1, h2;
        state_.Final(&amp;h1, &amp;h2);
        return h1;
    }

};
</pre></blockquote>

<p>
Indeed, this has become our algorithm of choice:
</p>

<blockquote><pre>
template &lt;class Hasher = spooky&gt; struct uhash;
</pre></blockquote>

<p>
<a href="https://131002.net/siphash/">SipHash</a> and the cryptographic
algorithms of the <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2 family</a>
are also efficiently adaptable to this framework.
</p>

<a name="switch_algorithm"></a><h3>What is involved in switching hashing algorithms?</h3>

<p>
Given the class X shown above, with its complex state distributed among at
least two different contiguous chunks of memory, and potentially many more
if the container switched from <code>vector</code> to <code>deque</code> or
<code>list</code>, one can create a <code>vector</code> of hash codes with a
preferred default algorithm like so:
</p>

<blockquote><pre>
for (auto const&amp; x : vx)
    hashes.push_back(uhash&lt;&gt;{}(x));
</pre></blockquote>

<p>
If one instead wanted to specify FNV-1a, the code is easily modified to:
</p>

<blockquote><pre>
for (auto const&amp; x : vx)
    hashes.push_back(uhash&lt;fnv1a&gt;{}(x));
</pre></blockquote>

<p>
This would change the hash code algorithm for every <code>vector</code>,
every <code>deque</code>, every <code>string</code>, every <code>char</code>,
every <code>int</code>, etc. for which X considered part of its hash-worthy state.
That is, hashing algorithms are controlled at the top of the data structure
chain, at the point where the client (e.g. <code>unordered_map</code>) asks for
the hash.  It is not controlled at all down at the bottom of the data structure
chain.  I.e. <code>int</code> has no clue how to hash itself.  It only knows
what state needs to be exposed to a hashing algorithm.
</p>

<p>
And there is no combining step.  The hash algorithm works identically as
if you had copied all of the various discontiguous chunks of state into
one big contiguous chunk of memory, and fed that one big chunk to the
hash algorithm.
</p>

<a name="pimpl"></a><h3>How does one <code>hash_append</code>
<a href="http://en.wikipedia.org/wiki/Pimpl#C.2B.2B">Pimpl</a> designs?</h3>

<p>
So far, every <code>hash_append</code> function shown must be templated on
<code>Hasher</code> so as to handle any hashing algorithm requested by some
unknown, far away client.  But with the 
<a href="http://en.wikipedia.org/wiki/Pimpl#C.2B.2B">Pimpl</a> design, one
can not send a templated <code>Hasher</code> past the implementation firewall.
</p>

<p>
Or can you ... ?
</p>

<p>
With a combination of <code>std::function</code> and <code>std::ref</code> one
can <i>type erase</i> the templated <code>Hasher</code>, adopting it to a type
with a concrete type, and pass that concrete <code>Hasher</code> through the
implementation firewall.  Imagine a class as shown
<a href="http://en.wikipedia.org/wiki/Pimpl#C.2B.2B">here</a>,
here is how it can support arbitrary hash algorithms with the proposed
infrastructure:
</p>

<blockquote><pre>
class Handle
{
    struct CheshireCat;               // Not defined here
    CheshireCat* smile;               // Handle

public:
    // Other operations...

    // Hash support
    using type_erased_Hasher = std::function&lt;void(void const*, std::size_t)&gt;;

    template &lt;class Hasher&gt;
    friend
    void
    hash_append(Hasher&amp; h, Handle const&amp; x)
    {
        using std::hash_append;
        if (x.smile == nullptr)
            hash_append(h, nullptr);
        else
            x.do_hash(type_erased_Hasher(std::ref(h)), *x.smile);
    }

private:
    void
    do_hash(type_erased_Hasher h, CheshireCat const&amp;) const;
};
</pre></blockquote>

<p>
So you still have to implement a templated <code>hash_append</code> for
<code>Handle</code>, but the implementation of that function forwards to a
<b>non-template</b> function which can be implemented in the source, alongside
of the definition of <code>CheshireCat</code>:
</p>

<blockquote><pre>
void
Handle::do_hash(Handle::type_erased_Hasher h, CheshireCat const&amp; c) const
{
    hash_append(h, c);
}
</pre></blockquote>

<p>
And now you can implement <code>hash_append</code> for <code>CheshireCat</code>,
but not for <i>any</i> <code>Hasher</code>, just for
<code>Handle::type_erased_Hasher</code>.  But besides this one detail (the type
of <code>Hasher</code>), <code>hash_append</code> for <code>CheshireCat</code>
looks just like any other <code>hash_append</code>:
</p>

<blockquote><pre>
friend
void
hash_append(Handle::type_erased_Hasher&amp; h, CheshireCat const&amp; c)
{
    using std::hash_append;
    hash_append(h, c.data1_, c.data2_, <i>etc.</i> ...);
}
</pre></blockquote>

<p>
Think about what has just happened here.  You've compiled CheshireCat.cpp today.
 And <i>tomorrow</i>, when somebody invents a brand new hash algorithm, your
CheshireCat.cpp uses it, with no re-compile necessary, for the cost of a virtual
function call to the <code>Hasher</code>.  And yet no other client of this new
<code>Hasher</code> (outside of those called by <code>CheshireCat</code>), is
forced to access the new hashing algorithm via a virtual function call. That
boarders on magic!
</p>

<p>
It is this very concern (hashing of Pimpl's) that decided the name of the
member function of <code>Hasher</code>s which appends state to the hash
algorithm:
</p>

<blockquote><pre>
void operator()(void const* key, std::size_t len) noexcept;
</pre></blockquote>

<p>
Had this member function been given any other name, such as:
</p>

<blockquote><pre>
void append(void const* key, std::size_t len) noexcept;
</pre></blockquote>

<p>
then programmers would not be able to use <code>std::function</code> to
create a type-erased wrapper around a templated <code>Hasher</code>.
</p>

<a name="testing"></a><h3>How does the quality of the resulting hash codes compare to the
<code>hash_combine</code> solution?</h3>

<p>
To answer this question X has been given a randomized default constructor:
</p>

<blockquote><pre>
std::mt19937_64 eng;

X::X()
{
    std::uniform_int_distribution&lt;short&gt; yeardata(1900, 2014);
    std::uniform_int_distribution&lt;unsigned char&gt; monthdata(1, 12);
    std::uniform_int_distribution&lt;unsigned char&gt; daydata(1, 28);
    std::uniform_int_distribution&lt;std::size_t&gt; veclen(0, 100);
    std::uniform_int_distribution&lt;int&gt; int1data(1, 10);
    std::uniform_int_distribution&lt;int&gt; int2data(-3, 5000);
    std::get&lt;0&gt;(date_) = yeardata(eng);
    std::get&lt;1&gt;(date_) = monthdata(eng);
    std::get&lt;2&gt;(date_) = daydata(eng);
    data_.resize(veclen(eng));
    for (auto&amp; p : data_)
    {
        p.first = int1data(eng);
        p.second = int2data(eng);
    }
}
</pre></blockquote>

<p>
Given this, one can easily create a great number of random X's as shown in the
loops above, and specify any hash algorithm.  One can also use
<code>std::hash</code> and "Solution 1" from the first part of this paper.
</p>

<p>
The hash function quality tester suite used herein is quite crude.
<code>test1</code> looks at each 64 bit hash code as a collection of 16
hex-digits.  The expectation is that each hex-digit should be roughly equally
represented in each hexadecimal place of the hash code.  The test returns
maximum deviation of the average, from the expected average.
</p>

<p>
The second test is extremely simple:  It is simply the number of collisions
divided by the number of available values in the hash code.  Zero is a perfect
result.
</p>

<p>
The third test is
<a href="https://code.google.com/p/smhasher/wiki/Distribution">TestDistribution</a>
gratefully borrowed from the
<a href="https://code.google.com/p/smhasher/wiki/SMHasher">smhasher</a>
test suite.
</p>

<p>
A million hash codes are generated from a million randomized but unique X's,
randomized by a default constructed <code>std::mt19937_64</code>, and fed to
these three tests.  For each test, the smaller the result the better.
</p>

<blockquote>
<table border="1" cellpadding="5">
<caption>Test Results -- smaller is better</caption>
<tr>
<th></th> <th>test 1</th> <th>test 2</th>  <th>test 3</th> <th>total time (sec)</th>
</tr>
<tr>
<th><code>hash_combine</code></th> <td>0.394544</td> <td>1.40071e-05</td> <td>0.984445</td> <td>0.419103s</td>
</tr>
<tr>
<th>FNV-1a</th> <td>0.029664</td> <td>0</td> <td>0.0719367</td> <td>0.829794s</td>
</tr>
<tr>
<th>Spooky V2</th> <td>0.011024</td> <td>0</td> <td>0.000902987</td> <td>0.634737s</td>
</tr>
<tr>
<th>CityHash</th> <td>0.015264</td> <td>0</td> <td>0.000662453</td> <td>2.68137s</td>
</tr>
</table>
</blockquote>

<p>
The <code>hash_combine</code> solution handily wins the speed test, but with a
quality that the obsolete FNV-1a function trounces.  It does no good to get the
wrong answer faster.  In contrast, the much more sophisticated Spooky V2
algorithm has a very high quality rating.
</p>

<p>
Note in the above results that though Spooky is far more complicated than
FNV-1a, it is actually faster for the type X, due to the optimizations based
on <code>is_contiguously_hashable</code>.  Without these optimizations,
Spooky would be slower than FNV-1a.
</p>

<p>
Even though CityHash is not easily efficiently adapted to this infrastructure,
it is easy to adapt it inefficiently:  Just collect the entire buffer in a
<code>vector&lt;char&gt;</code> and hash the whole thing during the finalization
step.  These results are shown just for informational purposes.
</p>

<a name="seeding"></a><h3>How does one apply random seeding?</h3>

<p>
Many hash algorithms can be randomly seeded during the initialization stage in
such a way that the hash code produced for a type is constant between
invocations by a single client (just like a non-seeded algorithm), but varies
between clients. The variance might be per-process, but could also be as
frequent as per-hash-functor construction, excluding copy or move construction.
In the latter case one might have two distinct <code>unordered_set</code>s
(for example) of the same type, and even containing the same data, and yet have
the two containers result in different hash codes for the same values.  Doing
so can help harden an application from attacks when the application must hash
keys supplied by an untrusted source.
</p>

<p>
This is remarkably easily done with this proposal.  One codes <i>one</i> new
hash functor, which can be used with <i>any</i> <code>Hasher</code> which
accepts a seed, and for <i>any</i> type which already has <code>hash_append</code>
implemented (even those <code>CheshireCat</code>s which have already been
compiled, and can not be recompiled).
</p>

<p>
Here is one possible implementation:
</p>

<blockquote><pre>
template &lt;class Hasher = spooky&gt;
class hardened_hash
{
    std::size_t seed_;
    static std::mt19937_64 rand_s;

public:
    using result_type = typename Hasher::result_type;

    hardened_hash() noexcept : seed_(rand_s()) {}
    explicit hardened_hash(std::size_t seed) noexcept
        : seed_(seed)
    {}

    template &lt;class T&gt;
    result_type
    operator()(T const&amp; t) const noexcept
    {
        Hasher h(seed_);
        using std::hash_append;
        hash_append(h, t);
        return static_cast&lt;result_type&gt;(h);
    }
};
</pre></blockquote>

<p>
In this example, the hashing algorithm is initialized with a random seed when
<code>hardened_hash</code> is default constructed.  Or it can also be given a
deterministic seed by the client at construction time.  In either case, once
constructed, the seed does not change except through hash functor assignment.
</p>

<p>
The same seed is used to initialize the algorithm on each hash functor
invocation. The seeded algorithm is then used to hash the entire message of the
type <code>T</code>, even down to the scalars embedded in <code>T</code> or the
sub-types of <code>T</code>.
</p>

<p>
One uses the same technique to apply
<a href="http://en.wikipedia.org/wiki/Salt_(cryptography)">salting</a>,
or <a href="http://en.wikipedia.org/wiki/Padding_(cryptography)">padding</a>
to a type to be hashed.  E.g. one would prepend and/or append the
<a href="http://en.wikipedia.org/wiki/Salt_(cryptography)">salt</a> or
<a href="http://en.wikipedia.org/wiki/Padding_(cryptography)">padding</a>
to the message of <code>T</code> by using additional calls to
<code>hash_append</code> in the <code>operator()(T const&amp; t)</code> of the
hash functor.
</p>

<a name="Summary"></a><h2>Summary</h2>

<p>
This paper presents an infrastructure that decouples types from hashing
algorithms.  This decoupling has several benefits:
</p>

<ul>
<li>Hash algorithm designers can concentrate on designing better hash
algorithms, with little worry about how these new algorithms can be
incorporated into existing code.</li>
<li>Type designers can create their hash support just once, without
worrying about what hashing algorithm should be used.</li>
<li>Clients can easily adopt most existing algorithms to this proposed
infrastructure.</li>
<li>Clients can very easily switch hashing algorithms used by
very complex data structures.</li>
<li>The resulting hash codes are a true reflection of the original design
of the hashing algorithms, even though applied to complex data structures
spanning discontiguous memory.</li>
</ul>

<a name="proposedinfrastructure"></a><h3>Summary of proposed infrastructure</h3>

<blockquote><pre>
template &lt;class T&gt; struct is_contiguously_hashable;                        // A type property trait
template &lt;class Hasher&gt; void hash_append(Hasher&amp; h, T const&amp; t) noexcept;  // overloaded for each type T
template &lt;class Hasher = <i>implementation-defined</i>&gt; struct uhash;             // A hashing functor
</pre></blockquote>

<a name="Acknowledgments"></a><h2>Acknowledgments</h2>

<p>
Special thanks to John Bytheway for pointing out the real-world utility of 
naming the "append" member of <code>Hasher</code> to <code>operator()</code>
in order to accommodate code which can't call <code>hash_append</code> from a
header.
</p>

<p>
Thanks to Daniel James (et al.) for highlighting the problem of hashing
zero-length containers with no message.
</p>

<p>
Thanks to Dix Lorenz (et al.) for pointing out that the <code>result_type</code> of the
<code>Hasher</code> need not be <code>size_t</code>, and indeed, can not be
if we want this infrastructure to fully handle cryptographic hash functions
(which produce results larger than a <code>size_t</code>).
</p>

<p>
Additional thanks to Walter Brown and Richard Smith for their invaluable review
and guidance.
</p>

<p>
This research has been generously supported by <a
href="https://www.ripplelabs.com">Ripple Labs</a>.  We would especially like to
thank our colleagues on the RippleD team.
</p>

</body>
</html>
