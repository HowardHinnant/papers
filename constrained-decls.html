<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>Yet another approach for constrained declarations</title>

	<style type="text/css">
        html {font-family: "DejaVu Serif", serif; size: medium; line-height: 150%; margin: 0; padding: 0;}
        code {font-family: "DejaVu Sans Mono", monospace; size: medium; line-height: 135%;}
        body {margin: 1em 2em; padding: 0;}
        h2 {margin: 1.5em 0 1em 0;}
	p, li {text-align:justify}
	ol.wide li {margin-top:1em;}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
        blockquote.std
        {
                max-width: 55em;
                border-left: thick solid #AAA;
                padding-left: 1em;
        }
	ins {color:#00A000}
	del {color:#A00000}
        p > code, li > code {color: #000080;}
	</style>
</head>
<body>

<address style="text-align:right;">
Document number: D????
<br/>
<br/>
<a href="mailto:ville.voutilainen@gmail.com">Ville Voutilainen</a><br/>
<a href="mailto:tkoeppe@google.com">Thomas K&ouml;ppe</a><br/>
<a href="mailto:andrew.n.sutton@gmail.com">Andrew Sutton</a><br/>
<a href="mailto:hsutter@microsoft.com">Herb Sutter</a><br/>
<a href="mailto:gdr@microsoft.com">Gabriel Dos Reis</a><br/>
<a href="mailto:bjarne@stroustrup.com">Bjarne Stroustrup</a><br/>
<a href="mailto:jason@redhat.com">Jason Merrill</a><br/>
<a href="mailto:hubert.reinterpretcast@gmail.com">Hubert Tong</a><br/>
<a href="mailto:eric.niebler@gmail.com">Eric Niebler</a><br/>
<a href="mailto:casey@carter.net">Casey Carter</a><br/>
2018-06-21<br/>
</address>
<hr/>
<h1 align=center>Yet another approach for constrained declarations</h1>

<h2>Abstract</h2>

<p>This paper proposes three things:</p>
<ol class="wide">
  <li>A syntax for constrained declarations that is practically a
    "constrained <code>auto</code>";
    the principle is "wherever <code>auto</code> goes,
    a <code>Constraint auto</code> can also go". The semantics are
    "deduce like <code>auto</code>, and additionally check a constraint".
    In a nutshell,
    <pre><code>    void f(Sortable auto x);
    Sortable auto f(); // #1
    Sortable auto x = f(); // #2
    template &lt;Sortable auto N&gt; void f();</code></pre>
    and combined all together,
    <pre><code>    template &lt;Sortable auto N&gt; Sortable auto f(Sortable auto x)
    {
        Sortable auto y = init;
    }</code></pre>
    An unconstrained version of that is
    <pre><code>    template &lt;auto N&gt; auto f(auto x)
    {
        auto y = init;
    }</code></pre>
    so this proposal includes <code>auto</code>-typed parameters for
    functions, which we already allow for lambdas.</li>

  <li>An additional relaxation where, for #1 and #2
    illustrated above, the <code>auto</code> is optional:
    <pre><code>    Sortable f();
    Sortable x = f();</code></pre></li>

  <li>Simplifying and thus restricting the rules in
    <a href="https://wg21.link/temp.param#10">[temp.param]/10</a>,
    so that <code>template &lt;Sortable S&gt;</code> always
    means that <code>S</code> is a type parameter, and
    <code>template &lt;Sortable auto S&gt;</code> always means
    that <code>S</code> is a non-type parameter. Template template-parameters
    are no longer supported in this short form. Moreover, <code>Sortable</code>
    is restricted to be a concept that takes a type parameter or parameter pack;
    non-type and template concepts are no longer supported in this short form.
  </li>
</ol>

<p><code>Sortable</code> is a "type concept" in all the examples of this abstract.</p>

<p>
  This paper specifically does <em>not</em> propose
</p>
<ul>
  <li>any new introduction syntax, or</li>
  <li>a new syntax for naming types.</li>
</ul>

<p>
  The idea of this approach is to provide a syntax that
</p>
<ul>
  <li>
    works for constrained parameters, constrained
    return types, constrained variables, and type-constrained
    non-type template parameters;
  </li>
  <li>
    avoids inventing many adventurous new things;
  </li>
  <li>
    in particular, avoids inventing new type sigils;
  </li>
  <li>
    does not clash with explicit template instantiations; and
  </li>
  <li>
    is compatible with what we already have in polymorphic
    lambdas, and makes functions uniform with them.
  </li>
</ul>

<h2>Part 1: &ldquo;Constrained <code>auto</code>&rdquo;</h2>

<p>
  The approach proposed here borrows a subset of
  <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0807r0.html">P0807R0 An Adjective Syntax for Concepts</a>. The idea is that
  we don't try to come up with a notation that does everything
  that P0807 does; in particular, there is no proposal for a new syntax
  to introduce a type name.
</p>

<p>
  The gist of the approach is simple: allow <code>auto</code> parameters in both
  polymorphic lambdas and function templates, and allow the <code>auto</code>
  to be preceded by a concept name. In every case, such a parameter
  is a deduced parameter, and we can see which parameters are deduced
  and which ones are not:
  <pre><code>    [](auto a, auto& b, const auto& c, auto&& d) {...}; // unconstrained
    [](Constraint auto a, Constraint auto& b, Constraint const auto& c, Constraint auto&& d) {...}; // constrained

    void f1(auto a, auto& b, const auto& c, auto&& d) {...}; // unconstrained
    void f2(Constraint auto a, Constraint auto& b, Constraint const auto& c, Constraint auto&& d) {...}; // constrained

    [](Constraint auto&& a, SomethingElse&& b) {...}; // a constrained deduced forwarding reference and a concrete rvalue reference
    void f3(Constraint auto&& a, SomethingElse&& b) {...}; // a constrained deduced forwarding reference and a concrete rvalue reference</code></pre>
</p>
<p>
  Seeing <code>auto</code> (even <code>Constraint auto</code>) in a parameter list
  tells us that we're dealing with a template. We know for
  each parameter whether it's deduced or not. We can tell apart
  concepts from types: concepts precede <code>auto</code>, types do not.
</p>
<p>
  Constrained return types work the same way:
  <pre><code>    auto f4();                  // unconstrained, deduced.

    Constraint auto f5();       // constrained, deduced.

    Whatever f6();              // See part 2. If Whatever is a type, not deduced.
                                // If Whatever is a concept, constrained and deduced.</code></pre>
</p>
<p>
  Note that <code>f4</code>, <code>f5</code> and <code>f6</code>
  are not templates (the previous <code>f1</code>, <code>f2</code>
  and <code>f3</code> <em>are</em> templates). There is no
  mention of <code>auto</code> in the parameter list. Again, we see
  when the return type is deduced, if we so choose.
</p>

<p>
  Constrained types for variables work the same way:
  <pre><code>    auto x1 = f1();             // unconstrained, deduced.

    Constraint auto x2 = f2();  // constrained, deduced.

    Whatever x3 = f3();         // See part 2. If Whatever is a type, not deduced.
                                // If Whatever is a concept, constrained and deduced.</code></pre>
</p>
<p>
  We can, again, easily see when deduction occurs, if we so choose.
</p>

<p>
  Since we can have deduced types for non-type template
  parameters, and we use <code>auto</code> there
  (as in <code>template &lt;auto N&gt; void f();</code>)
  we allow a constraint there, too:
</p>
<pre><code>    template &lt;Constraint auto N&gt; void f2();</code></pre>
<p>
  Note however that this can only be a type constraint; non-type concepts
  (including auto concepts) are not allowed in this form.
</p>

<p>
  Partial concept identifiers also work. Given a concept
  <code>template &lt;typename A, typename B&gt; concept
    Constructible = /* ... */;</code>, we can say:
  <pre><code>    void f(Constructible&lt;int&gt; auto x);   // Constructible&lt;decltype(x), int&gt; is satisfied

    Constructible&lt;int&gt; auto f();

    Constructible&lt;int&gt; auto x = f();

    template &lt;Constructible&lt;int&gt; auto N&gt; void f();
  </code></pre>
</p>

<p>
  In concert with the general approach "<code>Constraint auto</code> goes wherever
  <code>auto</code> goes", new-expressions and operators work:
  <pre><code>    auto alloc_next() { return new Sortable auto(this->next_val()); }

    operator Sortable auto() { }
  </code></pre>
</p>

<h2>Part 2: Relaxed &ldquo;constrained <code>auto</code>&rdquo;</h2>

<p>
  In function return types, we can leave out the <code>auto</code>.
  So, in addition to
  <pre><code>    Constraint auto f1();</code></pre>
  we can write
  <pre><code>    Constraint f2();</code></pre>
</p>
<p>
  Neither <code>f1</code> nor <code>f2</code> are templates.
  It seems fairly reasonable to allow omitting the <code>auto</code>,
  but that is intended to be a relaxation of the general rule,
  not a replacement for <code>Constraint auto</code>.
</p>

<p>
  In variable declarations, omitting the <code>auto</code>
  also seems reasonable:
  <pre><code>    Constraint x = f2();</code></pre>
</p>
<p>
  Note, in particular, that we already have a syntax that
  does (partial) deduction but doesn't make that explicit in the syntax:
  <pre><code>    std::tuple x = foo();</code></pre>
</p>
<p>
  The variable case in particular seems reasonable, considering
  the already existing deduction syntaxes that don't call
  attention to deduction. The user always has a choice to use
  a more explicit syntax. The return type case might well have
  a weaker rationale for being allowed. It should be noted, though,
  that this relaxation in general was present in the TS, this
  paper is merely not proposing it for parameters.
</p>
<p>
  Certain disambiguation details need to be handled:
  <pre><code>    bool b(Constructible&lt;int&gt; && bar());         // variable definition

    void foo() {
        Constructible&lt;int&gt; * f2();               // disambiguation/type-name interpretation rule required
        Constructible&lt;int&gt; * selector = f2();    // (same?) disambiguation/type-name interpretation rule required
    }
  </code></pre>
</p>

<h2>Part 3: Meaning of &ldquo;<code>template &lt;Concept T&gt;</code>&rdquo;</h2>

<p>
  In <a href="https://wg21.link/temp.param#10">[temp.param]/10</a> we have:
</p>
<blockquote class="std">
  A <em>constrained-parameter</em> declares a template parameter whose kind (type, non-type, template) and type
  match that of the prototype parameter (17.6.8) of the concept designated by the <em>qualified-concept-name</em>
  in the <em>constrained-parameter</em>. Let <code>X</code> be the prototype parameter of the designated concept.
  The declared template parameter is determined by the kind of <code>X</code> (type, non-type, template)
  and the optional ellipsis in the <em>constrained-parameter</em> as follows.
  <ul>
    <li>If <code>X</code> is a type <em>template-parameter</em>,
      the declared parameter is a type <em>template-parameter</em>.</li>
    <li>If <code>X</code> is a non-type <em>template-parameter</em>,
      the declared parameter is a non-type <em>template-parameter</em>
      having the same type as <code>X</code>.</li>
    <li>If <code>X</code> is a template <em>template-parameter</em>,
      the declared parameter is a template <em>template-parameter</em>
      having the same <em>template-parameter-list</em> as <code>X</code>,
      excluding default template arguments.</li>
    <li>If the <em>qualified-concept-name</em> is followed by an ellipsis,
      then the declared parameter is a template parameter pack (17.6.3).</li>
  </ul>

  [<em>Example</em>:<pre><code>    template&lt;typename T&gt; concept C1 = true;
    template&lt;template&lt;typename&gt; class X&gt; concept C2 = true;
    template&lt;int N&gt; concept C3 = true;
    template&lt;typename... Ts&gt; concept C4 = true;
    template&lt;char... Cs&gt; concept C5 = true;

    template&lt;C1 T&gt; void f1();       // OK, T is a type template-parameter
    template&lt;C2 X&gt; void f2();       // OK, X is a template with one type-parameter
    template&lt;C3 N&gt; void f3();       // OK, N has type int
    template&lt;C4... Ts&gt; void f4();   // OK, Ts is a template parameter pack of types
    template&lt;C4 T&gt; void f5();       // OK, T is a type template-parameter
    template&lt;C5... Cs&gt; void f6();   // OK, Cs is a template parameter pack of chars</code></pre>
  &ndash; <em>end example</em>]
</blockquote>

<p>
  Does that seem like a mouthful?
</p>
<p>
  That's because it is. In <code>template &lt;Constraint T&gt;</code>, what
  <code>T</code> is depends on what the template parameters of <code>Constraint</code> are.
  What this paper is proposing is that for such a constrained-parameter
  syntax, <code>T</code> would always be a type, and <code>Constraint</code>
  would always need to be a concept that has a corresponding type parameter
  or a type parameter pack.
</p>
<p>
  This paper is not proposing disallowing concepts with non-type
  parameters or template template parameters. What's being proposed
  is merely that the constrained parameter shortcut is not provided
  for those things, and that</p>
<ul>
  <li>the use of such concepts needs a requires-clause</li>
  <li>the constrained parameter syntax means just one thing
    when used with a concept (and has its original meaning
    when used with a type, which is a non-type template parameter)</li>
</ul>
<p>
  The rationale for this part is as follows:
</p>
<ol>
  <li>It seems desirable to have the constrained template parameter syntax</li>
  <li>It would be nice if that syntax covered the most common case</li>
  <li>It would further be nice if that syntax covered <em>only</em> the most
    common case</li>
  <li>The other cases are expected to be so rare that there's no
    need to provide a shortcut for them, and certainly rare enough
    that they shouldn't use the same syntax</li>
</ol>
<p>
  So, to clarify:
</p>
<ul>
  <li><code>template &lt;MyIntTypeDef N&gt;</code> means
    a non-type parameter, like it always did.</li>
  <li><code>template &lt;ConceptName T&gt;</code> means
    a type parameter constrained by <code>ConceptName</code>,
    and <code>ConceptName</code> needs to be a concept with
    a type parameter or a pack parameter.</li>
  <li><code>template &lt;auto N&gt;</code> means a non-type parameter
    with a deduced type.</li>
  <li><code>template &lt;ConceptName auto N&gt;</code> means
    a non-type parameter with a deduced type constrained by
    <code>ConceptName</code>, and <code>ConceptName</code>
    needs to be a concept with a type parameter or a pack parameter.</li>
</ul>
<p>
  Other use cases can be done with requires-clauses.
</p>

</body>
</html>
