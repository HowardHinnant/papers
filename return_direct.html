<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>Response To: Let return Be Direct and explicit</title>

	<style>
	p {text-align:justify}
	li {text-align:justify}
	blockquote.note
	{
		background-color:#E0E0E0;
		padding-left: 15px;
		padding-right: 15px;
		padding-top: 1px;
		padding-bottom: 1px;
	}
	ins {color:#00A000}
	del {color:#A00000}
	</style>
</head>
<body>

<address align=right>
<br/>
<br/>
<a href="mailto:howard.hinnant@gmail.com">Howard E. Hinnant</a><br/>
2014-06-18<br/>
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
<img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/4.0/80x15.png" /></a><br />
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
</address>
<hr/>
<h1 align=center>Response To: Let <code>return</code> Be Direct and <code>explicit</code></h1>

<h2>Contents</h2>

<ul>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Example">The Counter-Example</a></li>
<li><a href="#ExamplePair">The <code>pair</code> Counter-Example</a></li>
<li><a href="#AnotherExample">Another Example</a></li>
<li><a href="#Summary">Summary</a></li>
</ul>

<a name="Introduction"></a><h2>Introduction</h2>

<p>
This paper is in response to:
</p>

<blockquote><p>
<a href="https://isocpp.org/files/papers/n4029.pdf">N4029: Let <code>return</code> Be Direct and <code>explicit</code></a>
</p></blockquote>

<p>
N4029 proposes (with the best of intentions) to ignore the
<code>explicit</code> qualifier on conversions when the conversion would take
place on a <code>return</code> statement.  For example:
</p>

<blockquote><pre>
struct Type2 { explicit Type2(int){} };

Type2 f2_braces()
{
    Type2 local2{2};
    return {2}; // error now, ok with adoption of N4029.
}

Type2 f2_parens()
{
    Type2 local2(2);
    return 2;    // error now, ok with adoption of N4029.
    return (2);  // error now, ok with adoption of N4029.
}
</pre></blockquote>

<p>
The motivation for this change is:
</p>

<blockquote>
<p>
I believe this is inconsistent because the named return type is just as
"explicit" a type as a named local automatic variable type. Requiring the
user to express the type is by definition redundant &mdash; there is no other
type it could be.
</p>
<p>
This is falls into the (arguably most) hated category of C++ compiler
diagnostics: "I know exactly what you meant. My error message even tells you
exactly what you must type. But I will make you type it."
</p>
</blockquote>

<p>
I can relate.  Unnecessary typing <i>is</i> frustrating.  However I believe
it is possible that ignoring the <code>explicit</code> qualifier on type
conversions, even if only restricted to <code>return</code> statements, could
turn <i>compile-time</i> errors into <i>run-time</i> errors.  Possibly
<i>very subtle run-time</i> errors (the worst kind).
</p>

<p>
How likely is it that such run-time errors might be introduced?
<i>&lt;shrug&gt;</i> Such conjecture is always highly speculative.  But in this
instance, I can offer a realistic example where exactly this would happen.
And it happens very close to our home: by ignoring the <code>explicit</code>
qualifier of the constructor of a <b>std-defined</b> class type.
</p>

<a name="Example"></a><h2>The Counter-Example</h2>

<p>
Bear with me while I set up the likelihood of this counter-example actually
happening in the wild...
</p>

<p>
Today in <code>&lt;string&gt;</code> we have the following functions which
turn a <code>std::string</code> into an arithmetic type:
</p>

<blockquote><pre>
int                stoi  (const string&amp; str, size_t* idx = 0, int base = 10);
long               stol  (const string&amp; str, size_t* idx = 0, int base = 10);
unsigned long      stoul (const string&amp; str, size_t* idx = 0, int base = 10);
long long          stoll (const string&amp; str, size_t* idx = 0, int base = 10);
unsigned long long stoull(const string&amp; str, size_t* idx = 0, int base = 10);

float       stof (const string&amp; str, size_t* idx = 0);
double      stod (const string&amp; str, size_t* idx = 0);
long double stold(const string&amp; str, size_t* idx = 0);
</pre></blockquote>

<p>
It seems quite reasonable that a programmer might say to himself:
</p>

<blockquote>
<p>
I would like to write a function that turns a <code>std::string</code> into
a <code>std::chrono::duration</code>.
</p>
</blockquote>

<p>
Which <code>duration</code>?  Well, let's keep it simple and say: any one of the
six "predefined" <code>duration</code>s: <code>hours</code>, <code>minutes</code>,
<code>seconds</code>, <code>milliseconds</code>, <code>microseconds</code>,
or <code>nanoseconds</code>.
</p>

<p>
What would be the syntax for doing this?  Well, it would be quite reasonable
to follow the same syntax we already have for <code>duration</code> literals:
</p>

<blockquote><pre>
2h     // 2 hours
2min   // 2 minutes
2s     // 2 seconds
2ms    // 2 milliseconds
2us    // 2 microseconds
2ns    // 2 nanoseconds
</pre></blockquote>

<p>
And here is quite reasonable code for doing this:
</p>

<blockquote><pre>
std::chrono::nanoseconds
stons(std::string const&amp; str)
{
    using namespace std::chrono;
    auto errno_save = errno;
    errno = 0;
    char* endptr;
    auto count = std::strtoll(str.data(), &amp;endptr, 10);
    std::swap(errno, errno_save);
    if (errno_save != 0)
        throw std::runtime_error("error parsing duration");
    if (str.data() &lt; endptr &amp;&amp; endptr &lt; str.data() + str.size())
    {
        switch (*endptr)
        {
        case 'h':
            return hours(count);
        case 'm':
            if (endptr + 1 &lt; str.data() + str.size())
            {
                switch (endptr[1])
                {
                case 'i':
                    if (endptr + 2 &lt; str.data() + str.size() &amp;&amp; endptr[2] == 'n')
                        return count;
                    break;
                case 's':
                    return milliseconds(count);
                }
            }
            break;
        case 's':
            return seconds(count);
        case 'u':
            if (endptr + 1 &lt; str.data() + str.size() &amp;&amp; endptr[1] == 's')
                return microseconds(count);
            break;
        case 'n':
            if (endptr + 1 &lt; str.data() + str.size() &amp;&amp; endptr[1] == 's')
                return nanoseconds(count);
            break;
        }
    }
    throw std::runtime_error("error parsing duration");
}
</pre></blockquote>

<p>
Here is a simplistic "are you breathing" test for this code:
</p>

<blockquote><pre>
int
main()
{
    using namespace std;
    using namespace std::chrono;
    cout &lt;&lt; stons("2h").count() &lt;&lt; "ns\n";
    cout &lt;&lt; stons("2min").count() &lt;&lt; "ns\n";
    cout &lt;&lt; stons("2s").count() &lt;&lt; "ns\n";
    cout &lt;&lt; stons("2ms").count() &lt;&lt; "ns\n";
    cout &lt;&lt; stons("2us").count() &lt;&lt; "ns\n";
    cout &lt;&lt; stons("2ns").count() &lt;&lt; "ns\n";
}
</pre></blockquote>

<p>
Ok, so what is my point?
</p>

<p>
There is a careless type-o / bug in <code>stons</code>.  Do you see it yet?
<code>stons</code> is not trivial.  But neither is it horribly complicated.
Nor is it contrived.  Nor is the bug in it contrived.  It is a type of bug
that occurs commonly.
</p>

<p>
Today the bug in <code>stons</code> results in a compile-time error.  This
compile-time error was intended by the designers of the
<code>&lt;chrono&gt;</code> library.
</p>

<p>
If we accept N4029, the bug in <code>stons</code> becomes a run-time error.
Have you spotted it yet?  Here is a clue.  The output of the test (with
N4029 implemented) is:
</p>

<blockquote><pre>
7200000000000ns
2ns
2000000000ns
2000000ns
2000ns
2ns
</pre></blockquote>

<p>
The error is this line that parses "min" after the count:
</p>

<blockquote><pre>
                        return count;
</pre></blockquote>

<p>
which should read:
</p>

<blockquote><pre>
                        return minutes(count);
</pre></blockquote>

<p>
Or if you prefer:
</p>

<blockquote><pre>
                        return minutes{count};
</pre></blockquote>

<p>
Note that:
</p>

<blockquote><pre>
                        return {count};
</pre></blockquote>

<p>
does not help at all.  It converts the same compile-time error into the same
run-time error, with or without the explicit <code>{}</code>.
</p>

<p>
Once the error is corrected, the correct output of the test is:
</p>

<blockquote><pre>
7200000000000ns
120000000000ns
2000000000ns
2000000ns
2000ns
2ns
</pre></blockquote>

<a name="ExamplePair"></a><h2>The <code>pair</code> Counter-Example</h2>

<p>
What if the return isn't a scalar?  For example is this just as unsafe?
</p>

<blockquote><pre>
return {5, 23};
</pre></blockquote>

<p>
If the return type is <code>pair&lt;chrono::seconds, chrono::nanoseconds&gt;</code>
(which still do not want to construct implicitly from <code>int</code>), then
this would <b>definitely not</b> be safe!
</p>

<p>
We never, never, never want to implicitly construct a <code>chrono::duration</code>
from an <code>int</code>.  Here is how we say that in C++:
</p>

<blockquote><pre>
template &lt;class Rep2&gt; constexpr <b>explicit</b> duration(const Rep2&amp; r);
</pre></blockquote>

<p>
That is, we put <code>explicit</code> on the constructor (or on a conversion
operator).  To change the language to ignore <code>explicit</code> in some
places is a dangerous direction.
</p>

<a name="AnotherExample"></a><h2>Another Example</h2>

<p>
Perhaps there is some defective quality about <code>chrono::duration</code>
which is causing the problem.  Is <code>chrono::duration</code> the <i>only</i>
problematic example?
</p>

<p>
Consider a class <code>OperatesOnData</code>.
</p>

<blockquote><pre>
class OperatesOnData
{
public:
    OperatesOnData(VerifiedData);  // knows that the Data has been verified
    // Use this constructor ONLY with verified data!
    explicit OperatesOnData(Data); // trusts that the Data has been verified
};
</pre></blockquote>

<p>
<code>Data</code> that comes from untrusted sources must first be verified to
make sure it is in the proper form, all invariants are met, etc.  This
unverified <code>Data</code> is verified with the type <code>VerifiedData</code>.
This <code>VerifiedData</code> can then be safely sent to <code>OperatesOnData</code>
with no further verification.
</p>

<p>
However verifying the data is expensive.  Sometimes <code>Data</code> comes
from a trusted source.  So the author of <code>OperatesOnData</code> has set
up an <b>explicit</b> constructor that takes <code>Data</code>.  Clients know
that <code>OperatesOnData</code> can't verify <code>Data</code> all
the time because of performance concerns.  So when they know that their
<code>Data</code> need not be verified, they can use an explicit conversion
to <code>OperatesOnData</code> to communicate that fact.
</p>

<p>
Is this the best design in the world?  That's beside the point.  This is a
reasonable design one might find coded in C++.
</p>

<p>
Now we need to get the <code>Data</code> and start working on it:
</p>

<blockquote><pre>
VerifiedData getData();

OperatesOnData
startOperation()
{
    return getData();
}
</pre></blockquote>

<p>
So far so good.
</p>

<p>
Three years go by, and the programmers responsible for this code change. 
C++17 decides that <code>return explicit {x};</code> (or whatever) is a good
idea.  And our maintenance programmer wants everyone to know that he's up
with the most recent recommended practice from the C++ committee.  The code
changes to:
</p>

<blockquote><pre>
VerifiedData getData();

OperatesOnData
startOperation()
{
    return {getData()};           // This, or
    return explicit {getData()};  // This, or whatever we decide...
}
</pre></blockquote>

<p>
No harm done.  The programmer doesn't really understand, and from reading the code,
it isn't really clear that any semantic change has occurred.
</p>

<p>
I belatedly realize with no small amount of horror that this compiles today:
</p>

<blockquote><pre>
VerifiedData getData();

OperatesOnData
startOperation()
{
    return {getData()};
}
</pre></blockquote>

<p>
My horror isn't that it compiles, nor that it has well-specified behavior. My
horror is that we're seriously considering changing the semantics of that
<i>existing</i> behavior. So this variant of <code>startOperation</code>
already exists today, with no encouragement needed from C++17 (already
encouraged by C++11).
</p>

<p>
Another three years goes by, and another turnover in maintenance
happens.  Because of some changes on the other side of a million line program,
it is now too expensive for <code>getData()</code> to do the verification as
it has acquired some new clients that must do verification anyway.  So
<code>getData()</code> changes to:
</p>

<blockquote><pre>
Data getData();
</pre></blockquote>

<p>
Bam.  Unverified data gets silently sent to <code>OperatesOnData</code>.
The original code was designed <i>precisely</i> to catch this very error
<i>at compile time</i>.
</p>

<blockquote><pre>
Data getData();

OperatesOnData
startOperation()
{
    return {getData()};
}

test.cpp:23:12: error: chosen constructor is explicit in copy-initialization
    return {getData()};
           ^~~~~~~~~~~
test.cpp:14:14: note: constructor declared here
    explicit OperatesOnData(Data); // trusts that the Data has been verified
             ^
1 error generated.
</pre></blockquote>

<p>
But through a series of mistakes, both by the programmers, and by the committee,
none of which by itself is a fatal mistake, a serious run time error (perhaps
a security breach) has been created.
</p>

<p>
It always takes more than one mistake to make something really bad happen
(airplane crash, nuclear accident, security breach at the bank, etc.).
</p>

<a name="Summary"></a><h2>Summary</h2>

<p>
For me, these examples stress the point that when a type author writes
"<code>explicit</code>", we should never ignore it.  Not on a <code>return</code>
statement.  Not anywhere.  The type author knows best.  He had the option to
not make his conversion <code>explicit</code>, and he felt strongly enough
about the decision to <i>opt-in</i> to an <code>explicit</code> conversion.
</p>

<p>
I recall that when <code>&lt;chrono&gt;</code> was going through the
standardization process, the entire committee felt <i>very strongly</i> that
<code>int</code> should never implicitly convert to a <code>duration</code>.
</p>

<p>
Surely there are plenty of other examples in the wild where the type authors
opt-in to an explicit conversion, with just as strong feelings about their
decision as we felt about <code>int</code> and <code>&lt;chrono&gt;</code>.
</p>

</body>
</html>
